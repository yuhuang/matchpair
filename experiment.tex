\section{Experiments}
The experiments compare the under-approximation with the over-approximation of the precise match pairs in two aspects for SMT encoding: feasibility of error detection and runtime performance. The under-approximated match pairs are generated by the new algorithm in the paper with different settings of the input K. The over-approximated match pairs are generated by the old algorithm \cite{}. The encodings are resolved by the SMT solver Z3 \cite{}. 

A series of experiments are conducted for six typical benchmark programs that are employed by other papers \cite{}. For each benchmark, the encoding is modified to test three types of errors including assertion violation, zero buffer incompatibility and orphaned receive deadlock. The results of all the errors are presented. The initial execution trace for testing all three errors are generated by instrumenting the MPI programs with manually written scripts and executing the programs by MPICH \cite{}, a public implementation of the MPI standard. The SMT encoding is generated by the rules in the prior work.
The assertion violation requires extra steps to encode the negation of the assertions with respect of the computation in the program. The zero buffer incompatibility is tested with extra rules to encode zero buffer semantics. The orphaned receive deadlock needs to encode the disjunction of the match pairs for each send for validating the potential deadlock. The assertion violation and the orphaned receive deadlock are tested under infinite buffer semantics. 
The experiments are run on a AMD A8 Quad Core processor with 6 GB of memory running Ubuntu 14.04 LTS. A time limit of 2 hours is set for each test. The test aborts the verification process if it does not complete within the time limit.

The results of the comparison are shown in \tableref{table:benchmarks}.  
The column ``Match" records the number of match pairs as input to the encoding. The column ``K" records the positive integer as input to the algorithm in the paper. When ``K" is assigned the symbol ``$\infty$", the match pairs are over-approximated and are generated by the algorithm in the prior work \cite{}. The columns ``EX", ``D", ``Time" and ``Impr" are present for each of the three errors. The column ``EX" indicates whether an error exists in the tested program. The column ``D" indicates whether the error is detected or not. The column ``Time" is for both constraint generation and solving. The notation ``TO" means ``time out" (exceeding the time limit set for each test). The column ``Impr" records the improvement of performance and is computed by the simple formula in (3), where $\mathrm{Time}(\infty)$ is the runtime of the encoding with the over-approximated match pairs, and $\mathrm{Time}(\mathrm{K})$ is the runtime of the same encoding with the match pairs generated by the algorithm in the paper with input K. 
\begin{equation}
\mathrm{Impr} = \frac{\mathrm{Time}(\infty)}{\mathrm{Time}(\mathrm{K})}
\end{equation}
According to (3), a higher value of $\mathrm{Impr}$ means a shorter runtime of the encoding with the match pairs for K.
The meaning of the symbol ``-" is ``unavailable": the test is not interesting for comparison.

\begin{savenotes}
\begin{table*}[t]
\begin{center}
\scriptsize
\caption{Tests on Selected Benchmarks}\label{table:benchmarks}
     \begin{threeparttable}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
         \multicolumn{5}{|c|}{Test Programs} & \multicolumn{4}{c|}{Assertion Violation} & \multicolumn{4}{c|}{Zero Buffer Incom\tnote{\textdagger}} & \multicolumn{4}{c|}{Deadlock}  \\ \hline
          $Name$ & \#Procs & \#Calls &K& \#Match & EX & D & Time& Impr &EX&D & Time & Impr& EX &D & Time &Impr\\ \hline
          \multirow{3}{*}{\textit{Diff2DNoBa}} & \multirow{3}{*}{16}& \multirow{3}{*}{188} & 1 & 514 & No & -- &3.508s & 19.35 & Yes &  &1.749s&3.07 & Yes&$\surd$ & 3.479s& 13.50 \\ \cline{4-17}
								&				&                               & 2 & 934 & No & -- & 47.484s & 1.43 & Yes & & 3.053s& 1.76 &Yes& $\surd$& 44.060s&1.07\\ \cline{4-17}
								&				&                               & $\infty$& 1,066 & No& -- & 67.875s& 1.00 & Yes & $\surd$ &5.375s&1.00&Yes & $\surd$& 46.974s &1.00\\ \hline
								\hline
	
	 \multirow{3}{*}{\textit{DeepComm}} & \multirow{3}{*}{5}& \multirow{3}{*}{180} & 1 & 240 & Yes & $\surd$& 0.837s & 1,647& No & -- & 0.875s & 291 & No & -- & --\tnote{s} & --\\ \cline{4-17}
								&				&                            & 5 & 960 & Yes & $\surd$& 10.547s & 131 & No & -- & 3.056s & 83 & No& --& --\tnote{s}& --\\ \cline{4-17}
								&				& 			     & $\infty$ & 2,760 & Yes & $\surd$ & 1,379s & 1.00 & No & -- & 255s  & 1.00 &No& --& --\tnote{s}& --\\ \hline
								\hline
								
	 \multirow{3}{*}{\textit{Pktuse}} & \multirow{3}{*}{5}& \multirow{3}{*}{2048} & 1 & 1,792 &Yes & $\surd$ & 180s & $>$40 & No & -- & 121s & $>$59 & No&--&--\tnote{s}&--\\ \cline{4-17}
								&				& 		       &  5   &    4,828      & Yes& $\surd$ & 564s & $>$13& No & -- & 449s & $>$16 &No&--&--\tnote{s}&--\\ \cline{4-17}
								&				& 		       &  $\infty$ & 99,328&Yes & -- & TO & --& No &-- &  TO & --&No&--&--\tnote{s}&--\\ \hline
								\hline
								
	 \multirow{3}{*}{\textit{MultiM}} & \multirow{3}{*}{3}& \multirow{3}{*}{266} & 1 & 500 & Yes  &$\surd$&10.892s& 295 & No & --& 8.312s&366 & No&-- &--\tnote{s} &-- \\ \cline{4-17}
								&				&                   & 5& 1,300 & Yes& $\surd$& 24.397s & 132 & No &-- &17.843s & 170&No&--&--\tnote{s}&--\\ \cline{4-17}
								&				&                   & $\infty$ & 20,300 & Yes & $\surd$ & 3,218s & 1.00& No&-- &  3,043s& 1.00&No&--&--\tnote{s}&--\\ \hline
								\hline
								
	 \multirow{3}{*}{\textit{Mismatch}} & \multirow{3}{*}{3}& \multirow{3}{*}{800} & 1 & 204 & No &-- &--\tnote{a} & --&No &-- & 2.904s & 3.06&Yes&$\surd$&2.160s& 6.61\\ \cline{4-17}
								&				& 			 & 30 & 622 & No&-- &--\tnote{a} &-- & No&-- & 3.297s& 2.69 &Yes&$\surd$&10.061s&1.42\\ \cline{4-17}
								&				& 			 & $\infty$& 793 &No &-- &--\tnote{a} &-- & No& --& 8.872s &1.00 &Yes&$\surd$&14.286s&1.00\\ \hline
								\hline
			
	 \multirow{3}{*}{\textit{Floyd}} & \multirow{3}{*}{32}& \multirow{3}{*}{528} &1& 1,928 & No&-- &29.925s & 0.97 & No & -- & 89.032s & 1.02 & No&--&--\tnote{s}&--\\ \cline{4-17}
								&				& 		     & 5&1,928 & No &-- &30.621s & 0.95 & No & -- & 90.908s& 1.00&No&--&--\tnote{s}&--\\ \cline{4-17}
								&				& 		     & $\infty$&1,928 &No &-- &29.043s &1.00 & No& -- &91.155s &1.00 &No&--&--\tnote{s}&--\\ \hline
           
        
         
\end{tabular}
\begin{tablenotes}
\item[\textdagger] All precise match pairs are needed to witness a program zero buffer incompatible.
\item[s] SMT analysis is not launched because no orphaned receive occurs in any execution.
\item[a] No assertion is inserted in the program.
\end{tablenotes}
     \end{threeparttable}
\end{center}
\end{table*}
\end{savenotes}

Six typical benchmarks are tested. \textit{Diffu2DNoBa} is modified from the program \textit{Diffusion 2D}, which uses barriers to “partition” the message communication into several sections \cite{}. \textit{Diffu2DNoBa} removes the barriers from the original program. As such, deadlocks are present in the new program.

\textit{DeepComm} a simple program with one receiver and 4 senders. In the program, the receiver issues 60 wildcard receives; each sender sends 15 messages to the receiver.
This scenario reflects the message non-determinism with 60 messages, such that the messages from different senders may race.

\textit{Pktuse} can be executed with 5 processes -- each of which randomly sends several messages to the other processes. The program uses wildcard receives only, therefore has a high degree of message non-determinism.

\textit{MultiM} is an extension to a program in the MCAPI library distribution \cite{}. The program adds extra iterations to the original program to generate longer execution trace. The assertions may be violated in possible executions.

\textit{Mismatch} implements the message communication that contains a orphaned receive deadlock \cite{}. No assertions are present in the program.

\textit{Floyd} implements the shortest path algorithm for all the pairs of nodes \cite{}. Each node communicates only with the immediate following neighbor. 

The results show that all the errors in the benchmarks can be efficiently detected by the SMT encoding with under-approximation of the precise match pairs that is generated by the algorithm in this paper. The benchmarks \textit{Diffu2DNoBa}, \textit{DeepComm}, \textit{Pktuse}, \textit{MultiM} and \textit{Mismatch} show that the performance can be highly improved, even with a small set of match pairs. For example, the value of $\mathrm{Impr}$ can be 1,647 for the benchmark \textit{DeepComm}, indicating that the runtime is highly improved.
Further, the match pairs for $K=1$ is sufficient to detect the errors in these programs. 
For example, the encoding runs under a second for $K=1$ to find a violated assertion for the program \textit{DeepComm}, while the runtime of the encoding with the over-approximated match pairs is more than 20 minutes. Also, the deadlock in the program \textit{Mismatch} can be detected under 3 seconds for $K=1$, while the encoding with the over-approximated match pairs needs to run 14 seconds for the same error. 

To check zero buffer incompatibility, the precise match pairs are required as any zero buffer incompatible program indicates that 
all possible schedules are infeasible under zero buffer semantics. For example, the zero buffer incompatibility for the program \textit{Diff2DNoBa} is only detected with the over-approximated match pairs. On the other hand, if a test shows that a program is zero buffer compatible with a small set of match pairs, then the program can never be incompatible with zero buffer semantics. This is because the test demonstrates that there is at least one feasible schedule that may occur under zero buffer semantics. The results show that most benchmarks are zero buffer compatible by efficiently testing them with a small set of match pairs.

For the orphaned receive deadlock, a prior static analysis is launched to find all the potential deadlocks in a program. If no potential deadlocks are found, then the SMT encoding is not required. For example, the deadlock test for the program \textit{MuitiM} is unavailable because no potential deadlock is detected.

Finally, the benchmark \textit{Floyd} shows that the runtime for $K=1$ is similar to the runtime for $K=\infty$. This is because the new algorithm with $K=1$ is sufficient to add all the potential sends for the receives in a common process into a single section. This result also show that the new algorithm may not scale for such programs.
