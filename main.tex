\section{Main Algorithm}

%Notations: 
%Process set $P$
%receive list $R(p_{dest})$
%send list $S(p_{src}, p_{dest})$

\algoref{algo:main} describes the general structure of the approach in this paper.
Intuitively, the algorithm sections each process, where each section contains a fixed number of sequential receives. It then distributes a sequence of sends from each sender process to match the receives in each section. The total number of sends is equal to the number of receives in each section. Finally, the algorithm generates the match pairs for the sends and the receives in the same section by simply comparing their ranks. The intuitive meaning of a rank is a non-negative integer that represents the position of a send or a receive in a specific sequence.

\begin{algorithm}
\caption{Main Entrance}\label{algo:main}
\begin{algorithmic}[1]
\For{$p_t\in \mathit{P}$}
%\State $N_{frm} \gets |frm_t|$
%\State $src(p)\gets\{p_1,p_2,\ldots,p_x\}$   \Comment{a set of all the potential sources for process $p$}
\While{$\mathit{NR}_{t}>0$}
\State $N_k\gets$\Call{SectionMatch}{$\mathit{k}$}
%$N_K \gets \Call{min}{|Src(p)|\times\mathit{K}, N_r(ALL,p)}$
\For{$p_f \in frm_t$}
\State $\mathit{NS_{tf}}\gets 0$
\EndFor
\State $\mathit{{NS}^\prime}\gets$\Call{DistributeSends}{$p_t$,$N_k$, $\mathit{NS}$}
\State $M\gets$\Call{MatchApprox}{$p_t$,$N_k$, $\mathit{{NS}^\prime}$}
\State \Call{remove}{$R_t$,$N_k$} 
%\State $R(p)\gets R(p)\setminus\{R(p)_i\mid 1\leq i\leq N_K\}$ 
\For{$p_{f^\prime} \in frm_t$} 
\If{$\mathit{NS}_{tf^\prime} > 0$}
\State \Call{remove}{$S_{tf^\prime}$,$\mathit{NS}_{tf^\prime}$}
\EndIf
%\State $S(p_i,p)\gets S(p_i,p)\setminus\{S(p_i,p)_j\mid 1\leq j\leq\mathit{n_s}(p_i,p)\}$
\EndFor
\EndWhile
\EndFor
\end{algorithmic}
\end{algorithm}

At a low level, the presentation needs to first explain a few data structures that are essential to the algorithm.
$\mathit{P}$ is a set of all the processes in a CTP. 
$frm_t$ is a set of the unique identifiers of all the senders for the receiver $p_t$. 
The identifier of a sender can be removed from $frm_t$ once the sender has no send to be distributed to $p_t$.
The list $R_t$ contains all the sequential receives in process $p_t$.
%$\mathit{NR}_{tf}$ is the number of the receives in $R_t$ where they can only match the sends from process $p_f$. 
%The source can be ``$\ast$" indicating the wildcard receives.
%If the source is equal to ``$A$", then 
$\mathit{NR}_{t}$ is the number of all the receives in $R_t$.
The list $S_{tf}$ contains all the sequential sends from the sender $p_f$ to the receiver $p_t$. 
$\mathit{NS}_{tf}$ is the number of the sends in $S_{tf}$ that are distributed to a specific section.

Given the data structures defined, the presentation explains \algoref{algo:main} in detail.
The algorithm iteratively checks each receive at line 2 until $R_t$ is empty.  
$\mathrm{SECTIONMATCH}$ computes the number of receives in each section at line 3. The value is assigned to $N_k$. 
$\mathrm{DISTRIBUTESENDS}$ updates the count of the distributed sends ($\mathit{NS}$) from each sender to a common section in the receiver $p_t$ at line 7. 
$\mathit{NS_{tf}}$ is initialized for each sender $p_f$ at line 4 through line 6.
$\mathrm{MATCHAPPROX}$ then stores the generated match pairs for each section in $M$ at line 8. 
Finally, the receives and the sends in each section are removed from the CTP at line 9 through line 14. 
The function $\mathrm{REMOVE}$ removes elements from the beginning of a list given two inputs: the list to remove from and the number of operations to remove. 

\subsection{Section Match}

$\mathrm{SECTIONMATCH}$ is a simple equation in (3).
\begin{equation}
\Call{min}{|frm_t|\times\mathit{k}, \mathit{NR}_{t}}
\end{equation}
The function $\mathrm{MIN}$ returns the minimum among two numbers: $|frm_t|\times\mathit{k}$ and $\mathit{NR}_{t}$.
The first number indicates that the algorithm, if possible, distributes roughly average $k$  sends from each sender and therefore, adds $|frm_t|\times\mathit{k}$ receives to a section. If there are not sufficient receives in $R_t$, then the algorithm adds all that remained in $R_t$ to the section, where the number is $\mathit{NR}_{t}$.


\begin{lemma}
\label{lemma:section}
Each receive in a CTP is added to exactly one section by \algoref{algo:main}; each send in the CTP is also added to exactly one section if $\mathrm{DISTRIBUTESENDS}$ distributes the same number of sends to match the receives in any section.
\end{lemma}
\begin{proof}
\algoref{algo:main} initializes $N_k$ the number of the receives in a single section by $\mathrm{SECTIONMATCH}$, and removes these receives from $R_t$ immediately after executing $\mathrm{MATCHAPPROXIMATE}$ at line 8. It is assumed that the same number of potential sends are distributed to the section by $\mathrm{DISTRIBUTESENDS}$ and are removed from $S_{tf^\prime}$ for each potential sender $p_{f^\prime}$ at line 12. Therefore, a receive or a send can only be added once. 
Further, \algoref{algo:main} exhaustively matches sections for all the receives in any process $p_t$ until $\mathit{NR}_{t}$ is equal to zero. 
%Also, it is assumed that the number of sends is equal to the number of receives in a CTP. 
%Each section also contains equivalent receives and sends. 
Therefore, all the receives and sends in the CTP are partitioned into sections. 
$\Box$
\end{proof}
\lemmaref{lemma:section} is used to prove the key theorem later in the paper.


