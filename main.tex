\section{Main Algorithm}

%Notations: 
%Process set $P$
%receive list $R(p_{dest})$
%send list $S(p_{src}, p_{dest})$

%This section describes the general structure of the approach in this paper.
\algoref{algo:main} presents how to generate match pairs for each process in a CTP. 
Intuitively, the algorithm sections each process, where each section contains a number of sequential receives. For each section, the algorithm distributes the same number of sends from multiple sender processes to match the receives in each section. Finally, the divided sections consisting of only sends and receives are input to the existing algorithm for match pair generation \cite{DBLP:conf/kbse/HuangMM13}. 

%a fixed number of sequential receives. It then distributes a sequence of sends from each sender process to match the receives in each section. The total number of sends is equal to the number of receives in each section. Finally, the algorithm generates the match pairs for the sends and the receives in the same section by simply comparing their ranks. The intuitive meaning of a rank is a non-negative integer that represents the position of a send or a receive in a specific sequence.

\begin{comment}
Sections = {}
cur = {}

while | R | \neq 0 {
  r = dequeue(R);
  S = ()
  if from(r) = * 
     Let S be such that \forall S' \in {S_i, S_j, ...} (count(S) \lte count(Sâ€™)) and | S | \neq 0)
	  count(S) += 1
  else
     Let S be such that S = Sender(r)

  cur = cur \cup {r, dequeue(S)}
  if \forall S \in {S_i, S_j, ...} (count(S) = k \vee |S| = 0 \vee | R | = 0)
     Sections  = Sections \cup {cur}
	  cur = {}
	  \forall S \in {S_i, S_j, ...} count(S) = 0;
}
\end{comment}


\begin{algorithm}
\caption{Main Entrance}\label{algo:main}
\begin{algorithmic}[1]
%\State $S\gets\emptyset$
\State $N_k\gets\Call{min}{|\mathit{sender}|\times k, |R|}$
\While{$|R|>0$}
\State $r \gets$ \Call{dequeue}{R}
\State $N_r\gets N_r+1$
\If{\Call{frm}{r}$=\ast$}
\State let $S$ be such that $\forall S^\prime \in \mathit{sender}(0<|S|\le |S^\prime| )$
\Else 
\State let $S$ be the sender of $r$
\EndIf
\State $s\gets$ \Call{dequeue}{$S$}
\If{$|S|=0$}
\State $\mathit{sender}\gets\mathit{sender} \setminus \{S\}$
\EndIf
%\State $S_i\gets S_i\cup\{s\}$ 
\State $\mathit{cur}\gets \mathit{cur}\cup \{r,s\}$
\If{$N_r=N_k$}
\State $\mathit{sections}\gets\mathit{sections}\cup\{\mathit{cur}\}$
\State $\mathit{cur}\gets\emptyset$
%\State $\forall S \in\{S_1,S_2,\ldots\}S\gets\emptyset$
\State $N_r\gets 0$
\State $N_k\gets\Call{min}{|\mathit{sender}|\times k, |R|}$
\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}



\begin{comment}

\begin{algorithm}
\caption{Main Entrance}\label{algo:main}
\begin{algorithmic}[1]
\For{$p_t\in \mathit{P}$}
%\State $N_{frm} \gets |frm_t|$
%\State $src(p)\gets\{p_1,p_2,\ldots,p_x\}$   \Comment{a set of all the potential sources for process $p$}
\While{$\mathit{NR}_{t}>0$}
\State $N_k\gets$\Call{SectionMatch}{$\mathit{k}$}
%$N_K \gets \Call{min}{|Src(p)|\times\mathit{K}, N_r(ALL,p)}$
\For{$p_f \in frm_t$}
\State $\mathit{NS_{tf}}\gets 0$
\EndFor
\State $\mathit{{NS}^\prime}\gets$\Call{DistributeSends}{$p_t$,$N_k$, $\mathit{NS}$}
\State $M\gets$\Call{MatchApprox}{$p_t$,$N_k$, $\mathit{{NS}^\prime}$}
\State \Call{remove}{$R_t$,$N_k$} 
%\State $R(p)\gets R(p)\setminus\{R(p)_i\mid 1\leq i\leq N_K\}$ 
\For{$p_{f^\prime} \in frm_t$} 
\If{$\mathit{NS}_{tf^\prime} > 0$}
\State \Call{remove}{$S_{tf^\prime}$,$\mathit{NS}_{tf^\prime}$}
\EndIf
%\State $S(p_i,p)\gets S(p_i,p)\setminus\{S(p_i,p)_j\mid 1\leq j\leq\mathit{n_s}(p_i,p)\}$
\EndFor
\EndWhile
\EndFor
\end{algorithmic}
\end{algorithm}

\end{comment}

\begin{comment}

\begin{algorithm}
\caption{Main Entrance}\label{algo:main}
\begin{algorithmic}[1]
\For{$p_t\in \mathit{P}$}
\State let $R_t$ be the sequence of receives in $p_t$
\State let $S_t$ be the set of sequences of sends where each sequence contains the sends from a specific sender to $p_t$
\While{$|R_t|>0$}
\State $N_k\gets$\Call{SectionMatch}{$\mathit{k}$}
\State $(P_r,P_s)\gets$\Call{DistributeSends}{$R_t$,$S_t$,$N_k$}
\State $M\gets$\Call{MatchApprox}{$P_r$,$P_s$}
\EndWhile
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{figure*}[tb]
\centering
\scalebox{0.8}{
\mprset{flushleft}
\begin{mathpar}
\inferrule[Deterministic Receive Command]
{
\mathit{frm}(r_0) = p_f \\ P_r = (r_a \ldots \bot) \\ P_r^\prime =  (r_0\ r_a\ \ldots \bot) \\
P_s(f) = (s_b\ \ldots\ \bot) \\ P_s^\prime = P_s[f\rightarrow(s_{f0}\ s_b\ \ldots\ \bot)] \\
N_k^\prime = N_k-1
}{
((r_0\ r_1\ \ldots\ \bot)\ ((0\rightarrow(s_0\ s_1\ \ldots\ \bot))\ \ldots (f\rightarrow(s_{f0}\ s_{f1}\ \ldots\ \bot))\ \ldots \bot)\ P_r\ P_s\ N_k)
\reduce{m} \\
((r_1\ \ldots\ \bot)\ ((0\rightarrow(s_0\ s_1\ \ldots\ \bot))\ \ldots (f\rightarrow(s_{f1}\ \ldots\ \bot))\ \ldots \bot)\ P_r^\prime\ P_s^\prime\ N_k^\prime)
}
\and
\inferrule[Wildcard Receive Command]
{
\mathit{frm}(r_0) = \ast \\ P_r = (r_a \ldots \bot) \\ P_r^\prime =  (r_0\ r_a\ \ldots \bot) \\
\forall f^\prime\in \mathit{frm}_t, P_s(f)\le P_s(f^\prime) \\ P_s(f) = (s_b\ \ldots\ \bot) \\ P_s^\prime = P_s[f\rightarrow(s_{f0}\ s_b\ \ldots\ \bot)] \\
N_k^\prime = N_k-1
}{
((r_0\ r_1\ \ldots\ \bot)\ ((0\rightarrow(s_0\ s_1\ \ldots\ \bot))\ \ldots (f\rightarrow(s_{f0}\ s_{f1}\ \ldots\ \bot))\ \ldots \bot)\ P_r\ P_s\ N_k)
\reduce{m} \\
((r_1\ \ldots\ \bot)\ ((0\rightarrow(s_0\ s_1\ \ldots\ \bot))\ \ldots (f\rightarrow(s_{f1}\ \ldots\ \bot))\ \ldots \bot)\ P_r^\prime\ P_s^\prime\ N_k^\prime)
}
\end{mathpar}
}
\caption{Machine reductions ($\reduce{m}$). }
\label{fig:machine}
\end{figure*}

\end{comment}

At a low level, the presentation needs to first explain a few data structures and functions that are essential to the algorithm.
$R$ is a list of all the sequential receives in a process.
$\mathit{sender}$ is a set of lists $\{S_i, S_j, \ldots\}$ that is the sends directed to the process grouped by the sending process.
$N_k$ is the number of receives in a single section.
$N_r$ is a number to count the receives added to the section and is initialized to $0$.
The set $\mathit{cur}$ is used to store the sends and receives in the current section. It is initialized to an empty set.
The set $\mathit{sections}$ is used to store all the sections.

Besides the data structures, the algorithm also applies two auxiliary functions. 
$\Call{dequeue}{L}$ removes and returns the first element in the list $L$.
$\Call{frm}{r}$ returns the sender ID of the receive $r$.



$\mathit{P}$ is a set of all the processes in a CTP. 
$frm_t$ is a set of the unique identifiers of all the senders for the receiver $p_t$. 
The identifier of a sender can be removed from $frm_t$ once the sender has no send to be distributed to $p_t$.
The list $R_t$ contains all the sequential receives in process $p_t$.
%$\mathit{NR}_{tf}$ is the number of the receives in $R_t$ where they can only match the sends from process $p_f$. 
%The source can be ``$\ast$" indicating the wildcard receives.
%If the source is equal to ``$A$", then 
$\mathit{NR}_{t}$ is the number of all the receives in $R_t$.
The list $S_{tf}$ contains all the sequential sends from the sender $p_f$ to the receiver $p_t$. 
$\mathit{NS}_{tf}$ is the number of the sends in $S_{tf}$ that are distributed to a specific section.

Given the data structures defined, the presentation explains \algoref{algo:main} in detail.
The algorithm iteratively checks each receive at line 2 until $R_t$ is empty.  
$\mathrm{SECTIONMATCH}$ computes the number of receives in each section at line 3. The value is assigned to $N_k$. 
$\mathrm{DISTRIBUTESENDS}$ updates the count of the distributed sends ($\mathit{NS}$) from each sender to a common section in the receiver $p_t$ at line 7. 
$\mathit{NS_{tf}}$ is initialized for each sender $p_f$ at line 4 through line 6.
$\mathrm{MATCHAPPROX}$ then stores the generated match pairs for each section in $M$ at line 8. 
Finally, the receives and the sends in each section are removed from the CTP at line 9 through line 14. 
The function $\mathrm{REMOVE}$ removes elements from the beginning of a list given two inputs: the list to remove from and the number of operations to remove. 

\subsection{Section Match}

$\mathrm{SECTIONMATCH}$ is a simple equation in (3).
\begin{equation}
\Call{min}{|frm_t|\times\mathit{k}, \mathit{NR}_{t}}
\end{equation}
The function $\mathrm{MIN}$ returns the minimum among two numbers: $|frm_t|\times\mathit{k}$ and $\mathit{NR}_{t}$.
The first number indicates that the algorithm, if possible, distributes roughly average $k$  sends from each sender and therefore, adds $|frm_t|\times\mathit{k}$ receives to a section. If there are not sufficient receives in $R_t$, then the algorithm adds all that remained in $R_t$ to the section, where the number is $\mathit{NR}_{t}$.


\begin{lemma}
\label{lemma:section}
Each receive in a CTP is added to exactly one section by \algoref{algo:main}; each send in the CTP is also added to exactly one section if $\mathrm{DISTRIBUTESENDS}$ distributes the same number of sends to match the receives in any section.
\end{lemma}
\begin{proof}
\algoref{algo:main} initializes $N_k$ the number of the receives in a single section by $\mathrm{SECTIONMATCH}$, and removes these receives from $R_t$ immediately after executing $\mathrm{MATCHAPPROX}$ at line 8. It is assumed that the same number of potential sends are distributed to the section by $\mathrm{DISTRIBUTESENDS}$ and are removed from $S_{tf^\prime}$ for each potential sender $p_{f^\prime}$ at line 12. Therefore, a receive or a send can only be added once. 
Further, \algoref{algo:main} exhaustively matches sections for all the receives in any process $p_t$ until $\mathit{NR}_{t}$ is equal to zero. 
%Also, it is assumed that the number of sends is equal to the number of receives in a CTP. 
%Each section also contains equivalent receives and sends. 
Therefore, all the receives and sends in the CTP are partitioned into sections. 
$\Box$
\end{proof}
\lemmaref{lemma:section} is used to prove the key theorem later in the paper.


