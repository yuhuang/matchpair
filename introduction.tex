\section{Introduction}
Asynchronous message passing is a prevalent programming model in high performance computing (HPC). There are several common problems in message passing applications, including assertion verification, zero buffer incompatibility, and deadlock. These problems are NP--Complete for message passing programs \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,HuangDeadlock}. This paper discusses only single-path programs in the context of concurrent trace programs (CTP) as they are typical of many HPC applications. A CTP is generated from an concrete execution trace.

The problems mentioned above are difficult to check because of message non-determinism that allows a receive to be match with more than one send by the runtime. Also, the program behavior varies between two buffering semantics, infinite buffer (messages are buffered in the system) and zero buffer (no buffering in the system). Further, typical message passing standard such as message passing interface (MPI) specifies a special communication that uses collective operations to synchronize a program leading to a more complex program behavior. 

%The prior work is inefficient in reasoning about the program behavior in CTPs \cite{}.   
%Intuitively, the prior work uses match pair to capture the potential matching for a send and a receive in the runtime. 
%The over-approximated match pairs (including all the precise match pairs and maybe a few match pairs that may never occur in the runtime) are generated to capture any possible message communication in the runtime. 
%The prior work then encodes an SMT problem to resolve the match pairs for a feasible schedule. However, the number of all possible match pair resolutions that an SMT solver considers may be increased to exponential the number of sends and receives, which makes the execution very slow for the solver.  

There are several solutions proposed for analyzing message passing behavior. The implicit way of capturing possible message communication includes dynamic analysis \cite{DBLP:conf/ppopp/VakkalankaSGK08,DBLP:conf/sbmf/SharmaGB12}, model checking \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}, and runtime verification \cite{DBLP:conf/sc/VetterS00,DBLP:conf/parco/KrammerBMR03,DBLP:conf/ptw/HilbrichSSM09}. These solutions do not scale for large message passing programs because of the state explosion when checking a massive number of program interleavings. There are also several solutions that explicitly capture all possible message communication in analysis \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,HuangDeadlock,DBLP:conf/fm/ForejtKNS14}. Intuitively, they use match pair to capture the potential matching for a send and a receive in the runtime. 
The over-approximated match pairs (including all the precise match pairs and maybe a few match pairs that may never occur in the runtime) are generated as input to the analysis.
An SMT problem is then encoded to resolve the match pairs for a feasible schedule. 
These works are more efficient in reasoning about the program behavior, however, still do not scale for many programs as the precise match pairs can be resolved in exponential ways, which makes the analysis very slow.  

%To scale for practical message passing applications, i.e., applications with large number of processes and messages, several works are proposed, including dynamic analysis, runtime verification, and dynamic debugging.
The algorithm in this paper is inspired by the match pair generation algorithm in the prior work.
This paper presents an efficient algorithm that is capable of computing a reduced set of the match pairs that may exist in any execution. The set can be used as input to an SMT encoding for error detection. The number of match pair resolutions is therefore drastically reduced leading to a scalable SMT encoding. Generally, the algorithm generates the match pairs iteratively in three steps. First, it matches a section in a CTP by queuing a sequence of receives in a common process where the number of the receives depends on a positive integer K configured by the user. It then distributes the same number of sends that may potentially match the receives from multiple processes to the section. And finally, it over-approximates the match pairs for the sends and receives in the same section by comparing the ranking. 

%The third step is inspired by the match pair generation algorithm in the prior work \cite{}. 

The key insight of the solution is that each section is considered independently for match pair generation.  
The algorithm does not generate the match pair for a send and a receive from two different sections, while in fact the send and the receive may match in the runtime. 
As a result, the algorithm is able to under-approximate the precise match pairs as input to an SMT problem. 
Due to the missed match pairs that are derived from matching sends and receives in different sections, the SMT problem may not encode the complete program behavior. However, if the problem is satisfiable, then it is known that a specific error exists for a feasible schedule that is resolved by the encoding. If the problem is unsatisfiable for the under-approximated match pairs, it does not mean that there are provably no errors for any feasible execution in the runtime. It is then necessary to generate a larger set of match pairs by a new input K to capture more behavior for detection.

%The number is dependent on the integer K. A lower value of K may generate a smaller set of match pairs. 

The paper includes the proof that the precise match pairs for any CTP can also be generated by bounding the positive integer K. The experiments further show that the new algorithm improves the prior work in the SMT encoding such that the runtime of error detection is drastically reduced and no errors detected by the prior work are missed.
The contributions include,
\begin{compactitem}
\item the efficient algorithm that under-approximates the precise match pairs for a CTP where the size depends on a positive integer K configured by the user,
\item the proof that the precise match pairs for any CTP can be generated by the new algorithm with an appropriate positive integer K, and
\item the benchmarks that demonstrate the new algorithm improves the prior approach in the SMT encoding such that the runtime of error detection is drastically reduced and all the errors detected by the prior work are not missed. 
\end{compactitem}

The rest of the paper is organized as follows: 
Sections 2 presents an example of a CTP; Section 3 discusses the general structure of an SMT encoding and the match pairs for message passing programs;  Section 4 presents the general algorithm in the paper and the section matching in the algorithm; Section 5 presents the send distribution in the algorithm; Section 6 presents the match approximation in the algorithm; Section 7 gives the proof that the precise match pairs can be generated; Section 8 gives the experimental results; Section 9 discusses the related work; and Section 10 is the conclusion and future work.
