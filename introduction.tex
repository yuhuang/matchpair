\section{Introduction}
Asynchronous message passing is a widely used programming model in high performance computing (HPC). There are several common problems in message passing applications, including assertion verification, zero buffer incompatibility, and deadlock. These problems are NP--Complete for single-path programs \cite{}. This paper discusses only single-path message passing programs as they are typical of many HPC applications. 

The problems in message passing programs are difficult to detect. The major reason is that the message non-determinism that allows a receive to be match with more than one send by the runtime. Also, the program behavior is different from two semantics, infinite buffer (messages are buffered in the system) and zero buffer (no buffering in the system). Further, some message passing standard such as message passing interface (MPI) allows collective operations to synchronize a program leading to complex program behavior. 

The prior work is not efficient in reasoning about the message communication in a concurrent trace program (CTP) \cite{}. The CTP is generated from an concrete execution trace.  
In precise, the prior work uses match pair of a receive and a send to capture a potential message communication in the runtime. 
The over-approximated set of match pairs (including all the precise match pairs and may be some match pairs that never occur in the runtime) are generated to capture all possible message communications for a program in the runtime. 
The prior work then uses an SMT encoding to resolve the match pairs for error detection. However, the size of the resolution may be exponential in the number of sends and receives, therefore, makes the error detection time consuming. 

To scale well for real message passing applications, i.e., applications with large number of processes and messages, several works are proposed including dynamic analysis, runtime verification, and dynamic debugging.

The paper presents an algorithm that efficiently computes a reduced set of the precise match pairs. The set can be used as input to an SMT encoding for error checking. The number of match pair resolutions in problem solving is therefore drastically reduced leading to a scalable SMT encoding. In precise, the algorithm iteratively generates the match pairs in three steps. First, it matches a section in a CTP by queuing a sequence of receives in a common process where the number of the receives depends on a positive integer K configured by the user. It then distributes the same number of sends that may potentially match the receives from multiple processes to the section. And finally, it over-approximates the match pairs for the sends and receives in the section by comparing the ranking. The third step is inspired by the match pair generation algorithm in the prior work \cite{}. The key insight of the solution is that the problem of approximating the match pairs for all the sends and receives in a CTP can be reduced to multiple sub-problems each considering only a subset of sends and a subset of receives that are grouped as a section. A send and a receive from two different sections are not considered for matching, even though they may match in the runtime. As such, the approach is able to highly reduce the match pairs as input to an SMT encoding based on the number of sub-problems. Again, the number is dependent on the integer K. A lower value of K may generate a smaller set of match pairs. 

The paper includes the proof that the precise match pairs for any CTP can be generated with a bounded positive integer K. Also, the experiments show that the new algorithm improves the prior work in the SMT encoding such that the runtime of error detection is drastically reduced and no errors detected by the prior work are missed.


The contributions include,
\begin{compactitem}
\item the efficient algorithm that under-approximates the precise match pairs for a CTP where the size depends on a positive integer K configured by the user,
\item the proof that the precise match pairs for any CTP can be generated by the algorithm above with an appropriate positive integer K, and
\item the benchmarks demonstrate that the new algorithm improves the prior approach in the SMT encoding such that the runtime of error detection is drastically reduced and all the deadlocks in the benchmarks are detected. 
\end{compactitem}

The rest of the paper is organized as follows:
