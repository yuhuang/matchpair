 \section{Introduction}
%Asynchronous message passing is a prevalent programming model in high performance computing (HPC). The model consists of two operations, send and receive, that are essential to message communication. The message communication is complicated because of the non-determinism that a receive may be matched with more than one send in the runtime. The use of match pair, a pair of a send and a receive that may potentially match in the runtime, is able to capture the message communication.
%The semantics can also be complicated because of two buffering settings in the runtime, infinite buffer (messages are buffered in the system) and zero buffer (no buffering in the system). Further, typical message passing standard such as message passing interface (MPI) specifies a special communication that uses collective operations to synchronize a program leading to a more complex program behavior. 
%Given the semantics, several common problems exist in message passing applications: the user-provided assertion may be violated in an execution; the program may deadlock for unexpected matching of receives; and the program may be incompatible with zero buffer semantics, meaning that no feasible schedule exists under zero buffer setting. 
Asynchronous message passing is a prevalent programming model in high performance computing (HPC).
The idea of message passing is simple at the outset; processes communicate by sending messages from one to another. It does not take long, however, to realize that despite the simplicity of the programming model, there is a lot of subtlety in message passing that can impact program behavior. For example, depending on the library, a programmer must be aware of such things as message non-determinism (concurrent sends to a process can arrive in any order), buffering semantics in the runtime (a process may block if the buffer is full), or broad synchronization operations that message with  groups of processes at the same time (i.e., collective operations). This inherent complexity means that the problems of determining if a message passing program is free of deadlock, compatible with a given buffering semantics, or if the message non-determinism affects the correctness of the computation are all NP-complete \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,DBLP:conf/fm/ForejtKNS14,deadlock-draft}. Showing any of these properties for an input program is hard.

Prior work on program correctness in the message passing paradigm can be roughly grouped into dynamic analysis where an existing runtime is manipulated to explore different scheduling outcomes \cite{DBLP:conf/ppopp/VakkalankaSGK08,DBLP:conf/sbmf/SharmaGB12}, model checking where a model of the original program is analyzed \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}, runtime verification where the program execution is observed but not manipulated \cite{DBLP:conf/sc/VetterS00,DBLP:conf/parco/KrammerBMR03,DBLP:conf/ptw/HilbrichSSM09}, and symbolic model checking where a model of the program is symbolically analyzed with an SMT solver \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15}. This paper looks specifically at symbolic model checking and ways to better leverage the SMT solver in witnessing program properties for message passing programs.

The most efficient types of encoding for symbolic model checking of message passing programs, where efficient means they scale to programs with a high degree of message non-determinism, rely on the concept of a \emph{match pair} and a \emph{concurrent trace program} abstraction (CTP) \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,deadlock-draft,DBLP:conf/fm/ForejtKNS14,DBLP:conf/atva/ElwakilYW10,DBLP:conf/issta/ElwakilY10}. 
A match pair is a send and receive pair that may be matched by the run-time in some feasible execution of the program \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,deadlock-draft,DBLP:conf/fm/ForejtKNS14,DBLP:conf/atva/ElwakilYW10,DBLP:conf/issta/ElwakilY10}. 
A CTP is an abstraction of the program that removes all branching so each process is a sequence of send, receive, and wait (e.g., a witness to the completion of a send or receive) operations \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15}. 
The abstraction is constructed by observing the execution of the program in the run time for a given input. Symbolic model checking gives the SMT solver an encoded CTP with a set of match pairs, and the solver then tries to select a subset of the given match pairs in such a way that the CTP deadlocks or violates an assertion. 

%The symbolic model checking requires a over-approximated set of match pairs as input. The set includes all the true match pairs and maybe a few match pairs that may never occur in the runtime. 
%The work then encodes the CTP into an SMT problem that uses a set of formulas to constrain the program behavior based on the semantics. The typical error such as deadlock, zero buffer incompatibility or assertion violation is then checked by solving the SMT problem. If a satisfying assignment exists for the SMT problem, then the error is detected where the match pairs are resolved to capture the message communication in a feasible program execution. If the SMT problem is unsatisfiable, the CTP is free of that error because no feasible schedule exists with any resolution of the match pairs. 

The size of the input match-pair set directly impacts the cost of the call to the SMT solver in the symbolic model checking of message passing programs; a large input set typically means an expensive solver call especially if there is a high-degree of message non-determinism. The idea in this paper is to reduce the cost of the solver call by reducing the size of the input match set to each call. Such a reduction cannot, however, be done naively; any match pair set must be \emph{message complete}.  A message complete match pair set for a CTP is one that lets the program run to completion (assuming it is free of deadlock). 

%As such, reducing the size of the input match pair set directly impacts the run time cost, typically, of the SMT solver. A straightforward idea to improve the performance, therefore, is to reduce the number of the match pairs. A naive way of reducing the match pairs such as randomly selecting a subset of the match pairs, however, is not sufficient. The input set of match pairs must be sufficient to complete the message communication in a program execution if the CTP is free of deadlock. A match pair set that has this property for a given CTP is termed \emph{message complete}.
%The input match pairs must satisfy two properties: program completion (the program can run to completion assuming no deadlocks exist) and message non-determinism (the set has a certain degree of non-determinism such that a receive may be associated with more than one match pairs).  
%The algorithm in this paper explores a way to generate such a reduced set of match pairs.

To reduce the number of match pairs and thereby decrease the cost of verification, this paper describes an iterative algorithm to successively generate under-approximations of the true set of match pairs until all match pairs are generated. The under-approximations retain the message complete property. 
Such an approach focuses on property witnessing rather than proofs of correctness as the intent is to witness program properties early in the iterations before the set of match pairs gets large.
%Since the correctness of a CTP can not be proved given an under-approximated set of match pairs, this paper only discusses the capability of error detection for the SMT encoding. 
%The primary goal is to improve bug finding in a CTP; although, since the algorithm is iterative, it is able to eventually produce a set of match pairs that includes all reachable match pairs in the CTP, therefore it proves correctness. 


Generally, the algorithm generates the match pairs in two steps. 
First, each process is sectioned, where a section contains a sequence of receives in the process and a number of sends from all the senders that may potentially match these receives. The number of sends from each sender is roughly bounded by  $k$ given as a user input. 
%For each section, the algorithm precisely adds a set of sequences of sends from multiple potential sender processes. 
The sends from each sender are distributed sequentially. 
The total number of the sends distributed to the section is equal to the number of receives in the same section. 
%The number of the receives depends on three values that are statically known: the positive integer $k$ configured by the user, the number of all the potential sender processes and the number of the unmatched receives in the process. 
Match pairs are then generated for each section independently. This independent sectioning effectively ignores combinations of match pairs, that are feasible, but only available when the considered concurrent outstanding sends are more than the number of receives in the section. 
The algorithm generates the match pairs for the sends and receives in each section by a list of simple rules based on ranks \cite{DBLP:conf/kbse/HuangMM13}. A rank is a non-negative integer that represents the position of a send or a receive in a specific sequence in the section.

Given the algorithm for match pair generation, the approach in this paper starts with $k=1$ and increments $k$ to a larger bound such that the number of the divided sections is changed, because the match pair generation for the new iteration is only meaningful if each process is sectioned differently. The growth of the size of the match pair set is polynomial as $k$ increases. The program property is then witnessed with the larger bound $k$; or the process repeats.


%Have you added the discussion that k jumps by increments greater than 1? Meaning that you move k until the number of sections changes? In many regards, that is what is critical; start with k=1, then move k until the # of sections changes, run the solver, repeat. Is that discussion in the paper?


%The key insight of the solution is that each section is considered independently for match pair generation.  
%The algorithm does not generate the match pair for a send and a receive from two different sections, while in fact the send and the receive may match in the runtime. 
%As a result, the algorithm is able to under-approximate the precise match pairs as input to an SMT problem. 
%Due to the missed match pairs that are derived from matching sends and receives in different sections, the SMT problem may not encode the complete program behavior. However, if the problem is satisfiable, then it is known that a specific error exists for a feasible schedule that is resolved by the encoding. As such, the SMT encoding with a reduced set of match pairs can be used to detect errors. If the problem is, however, unsatisfiable for the under-approximated match pairs, it does not mean that there are provably no errors for any feasible execution in the runtime. It is then necessary to generate a larger set of match pairs by a new input K to capture more behavior for detection.


The paper includes the discussion that the precise match pairs for any CTP can be generated with a sufficiently large bound $k$. 
Experiments further show that the runtime cost of witnessing properties is dramatically reduced as the properties are witnessed with relatively small values of $k$ creating simple problem instances for the SMT solver. 
Experiments also show that the algorithm is able to scale to a program that employs a high degree of message non-determinism and/or a high degree of deep communication.
Deep communication in this context means that each sender for a receiver issues a long sequence of sends to the receiver.
The contributions include,
\begin{compactitem}
\item the efficient algorithm that under-approximates the precise match pairs for a CTP, 
%where the size depends on a positive integer $k$ configured by the user,
\item the proof that the precise match pairs for any CTP can be generated by the new algorithm with a sufficiently large bound $k$, and
\item the results from the experiments using a set of benchmarks to demonstrate the improved ability of witnessing program properties.
\end{compactitem}

The rest of the paper is organized as follows: 
Sections 2 presents the definition and semantics of CTP; Section 3 presents the general algorithm in the paper; Section 4 states that the precise match pairs can be generated; Section 5 gives the experimental results; Section 6 discusses the related work; and Section 7 is the conclusion and future work.
