 \section{Introduction}
Asynchronous message passing is a prevalent programming model in high performance computing (HPC). The model consists of two operations, send and receive, that are essential to message communication. The message communication is complicated because of the non-determinism that a receive may be matched with more than one send in the runtime. The use of match pair, a pair of a send and a receive that may potentially match in the runtime, is able to capture the message communication.
The semantics can also be complicated because of two buffering settings in the runtime, infinite buffer (messages are buffered in the system) and zero buffer (no buffering in the system). Further, typical message passing standard such as message passing interface (MPI) specifies a special communication that uses collective operations to synchronize a program leading to a more complex program behavior. 
Given the semantics, several common problems exist in message passing applications: the user-provided assertion may be violated in an execution; the program may deadlock for unexpected matching of receives; and the program may be incompatible with zero buffer semantics, meaning that no feasible schedule exists under zero buffer setting. 

These problems are NP--Complete and can be detected by the prior works \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,HuangDeadlock}. The crucial idea behind the prior works is executing a message passing program to several traces. Each trace is restructured as a concurrent trace program (CTP) where the processes are statically known; and the sequential order of each process is maintained. Also, only the operations in a single path of the original program exist in the CTP where the path conditions are added to a set of assume operations to constrain the same path. This paper also considers CTPs in the discussion. The over-approximated match pairs for all the sends and receives in each CTP (including all the precise match pairs and maybe a few match pairs that may never occur in the runtime) are generated as input to the analysis. The prior works then encode the CTP into an SMT problem that uses a set of formulas to constrain the program behavior based on the semantics. The typical errors are then checked by solving the SMT problem. If a satisfying assignment exists for the SMT problem, then the error is detected for a feasible schedule with a resolution of the match pairs to capture the message communication in the schedule. If the SMT problem is unsatisfiable, the CTP is free of that error because no feasible schedule exists with any resolution of the match pairs. 

An important aspect that impacts the performance of the SMT encoding is the size of the input match pairs. The encoding can be resolved much slowly if the number of the match pairs is large because there can be exponential ways to resolve these match pairs. As such, a straightforward idea to improve the performance is to reduce the size of the match pairs. However, a naive way of reducing the match pairs such as randomly selecting a subset of the match pairs is not sufficient. The input set of match pairs must satisfy two properties: the program can run to completion assuming no deadlocks exist; and the set has a certain degree of non-determinism such that a receive may be associated with more than one match pairs.   
The algorithm in this paper explores a way to generate such a reduced set of match pairs.


Besides the works mentioned above that explicitly capture the message communication, there are several solutions that use the implicit way to analyze possible message communication, including dynamic analysis \cite{DBLP:conf/ppopp/VakkalankaSGK08,DBLP:conf/sbmf/SharmaGB12}, model checking \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}, and runtime verification \cite{DBLP:conf/sc/VetterS00,DBLP:conf/parco/KrammerBMR03,DBLP:conf/ptw/HilbrichSSM09}. These solutions, however, do not scale for large message passing programs because of the state explosion when checking a massive number of program interleavings. 


%There are also several solutions that explicitly capture all possible message communication in analysis \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15,HuangDeadlock,DBLP:conf/fm/ForejtKNS14}. Intuitively, they use match pair to capture the potential matching for a send and a receive in the runtime. 
%The over-approximated match pairs (including all the precise match pairs and maybe a few match pairs that may never occur in the runtime) are generated as input to the analysis.
%An SMT problem is then encoded to resolve the match pairs for a feasible schedule. 
%These works are more efficient in reasoning about the program behavior, however, still do not scale for many programs as the precise match pairs can be resolved in exponential ways, which makes the analysis very slow.  

%To scale for practical message passing applications, i.e., applications with large number of processes and messages, several works are proposed, including dynamic analysis, runtime verification, and dynamic debugging.
This paper presents an efficient algorithm that is capable of computing a reduced set of match pairs for a CTP. The number of match pair resolutions for an SMT problem is therefore drastically reduced leading to a scalable analysis. Generally, the algorithm generates the match pairs iteratively in three steps. First, it matches a section in a CTP by queuing a sequence of receives in a common process where the number of the receives depends on a positive integer K configured by the user. It then distributes the same number of sends that may potentially match the receives from multiple processes to the section. And finally, it matches the sends and receives in the same section by a list of simple rules based on ranks. Note that the rank is used to strictly order a send or a receive in a specific sequence in the section.

The key insight of the solution is that each section is considered independently for match pair generation.  
The algorithm does not generate the match pair for a send and a receive from two different sections, while in fact the send and the receive may match in the runtime. 
As a result, the algorithm is able to under-approximate the precise match pairs as input to an SMT problem. 
Due to the missed match pairs that are derived from matching sends and receives in different sections, the SMT problem may not encode the complete program behavior. However, if the problem is satisfiable, then it is known that a specific error exists for a feasible schedule that is resolved by the encoding. As such, the SMT encoding with a reduced set of match pairs can be used to detect errors. If the problem is, however, unsatisfiable for the under-approximated match pairs, it does not mean that there are provably no errors for any feasible execution in the runtime. It is then necessary to generate a larger set of match pairs by a new input K to capture more behavior for detection.


The paper includes the proof that the precise match pairs for any CTP can also be generated by bounding the positive integer K. Experiments further show that the new algorithm improves the prior work in the SMT encoding such that the runtime of error detection is drastically reduced and all the errors in the benchmarks are detected with the reduced match pairs.
The contributions include,
\begin{compactitem}
\item the efficient algorithm that under-approximates the precise match pairs for a CTP where the size depends on a positive integer K configured by the user,
\item the proof that the precise match pairs for any CTP can be generated by the new algorithm with an appropriate positive integer K, and
\item the benchmarks that demonstrate the new algorithm improves the prior approach in the SMT encoding such that the runtime of error detection is drastically reduced and all the errors detected by the prior work are not missed. 
\end{compactitem}

The rest of the paper is organized as follows: 
Sections 2 presents an example of a CTP; Section 3 presents the general algorithm in the paper and the section matching in the algorithm; Section 4 presents the send distribution in the algorithm; Section 5 presents the match approximation in the algorithm; Section 6 gives the proof that the precise match pairs can be generated; Section 7 gives the experimental results; Section 8 discusses the related work; and Section 9 is the conclusion and future work.
