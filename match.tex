\subsection{Match Pair Approximation}

$\mathrm{MATCHAPPROX}$ in \algoref{algo:main} directly applies the over-approximation algorithm in the prior work \cite{DBLP:conf/kbse/HuangMM13} to generate the match pairs for the sends and receives in a specific section.
Intuitively, the algorithm checks all the pairs of receives and sends in the section, and prunes obvious matches that cannot exist in any runtime implementation of the specification by comparing ranks of sends and receives. 
A rank of a receive is its position in the receive list for the section. 
A rank of a send is its position in the send list from a particular sender to the section.    
Please refer to the prior work \cite{DBLP:conf/kbse/HuangMM13} for more detail of the algorithm. 


$\mathrm{MATCHAPPROX}$ in \algoref{algo:main} implies the ``match over-approximation" property in the prior work \cite{DBLP:conf/kbse/HuangMM13}. The paper presents this property in \lemmaref{lemma:match}. 

\begin{lemma}
$\mathrm{MATCHAPPROX}$ in \algoref{algo:main} over-approximates the match pairs for all the receives and sends in a specific section; that is saying, that all the precise match pairs (and maybe some unprecise match pairs) in the section are added to the output $M$.
\label{lemma:match}
\end{lemma}

%\begin{proof}
%\algoref{algo:match} must never claim to be able to prune the precise match pairs. The algorithm considers all the pairs for a send and a receive in a specific section. Also, the condition at line 4 only prunes the pairs that may never occur in the runtime: the first rule validates the endpoints consistent for the send and the receive; the second and third rules validate the FIFO order in message delivery according to the semantics. Therefore, only unprecise match pairs are pruned. $\Box$
%\end{proof}


%The condition at line 4 is then used to soundly prune the pair of $R(p)_i$ and $S(p_s,p)_j$ if they never match in the runtime with three rules. The first rule indicates that $R(p)_i$ is either a wildcard receive (the receive that may match a send from any source) or the source of $R(p)_i$ matches the source of $S(p_s,p)_j$. The second rule indicates that $i$ is greater or equal to $j$ meaning that the sends preceding $S(p_s,p)_j$ in $S(p_s,p)$ have to be matched with the receives in $p$. 